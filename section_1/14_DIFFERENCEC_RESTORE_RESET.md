## تفاوت‌های فنی بین `git reset` و `git restore`

دستورات `git reset` و `git restore` هر دو برای بازگرداندن تغییرات به حالت قبلی در گیت استفاده می‌شوند، اما هر کدام هدف و کاربرد خاص خود را دارند. در حالی که هر دو دستور به بازگرداندن تغییرات می‌پردازند، تفاوت‌های اساسی و فنی بین آن‌ها وجود دارد. در این مستند، به مقایسه‌ی فنی و مفهومی این دو دستور می‌پردازیم و موارد استفاده‌ی هر کدام را شرح می‌دهیم.

### 1. **هدف اصلی و فلسفه طراحی**

#### `git reset`:

- **هدف اصلی:** `git reset` ابزاری قدرتمند برای **تغییر HEAD و شاخه فعلی** است. این دستور بیشتر روی شاخه‌ها و تاریخچه کامیت‌ها متمرکز است و اجازه می‌دهد که شاخه فعلی را به یک کامیت قبلی بازگردانید و وضعیت مرحله آماده‌سازی (staging area) و دایرکتوری کاری (working directory) را تغییر دهید.
- **فلسفه طراحی:** این دستور برای مدیریت **تاریخچه پروژه** طراحی شده است و معمولاً برای اصلاح شاخه‌ها و کامیت‌ها، تغییر مکان HEAD و تنظیم مجدد مرحله آماده‌سازی استفاده می‌شود.

#### `git restore`:

- **هدف اصلی:** `git restore` برای **بازگرداندن فایل‌ها** در دایرکتوری کاری و مرحله آماده‌سازی طراحی شده است. تمرکز این دستور بیشتر بر روی **فایل‌ها** است و به شما کمک می‌کند که تغییرات در فایل‌ها را به حالت قبلی برگردانید یا فایل‌های آماده‌سازی‌شده را از مرحله آماده‌سازی خارج کنید.
- **فلسفه طراحی:** `git restore` برای مدیریت دقیق‌تر **فایل‌های تغییر یافته** طراحی شده و بیشتر برای بازگرداندن فایل‌ها به حالت قبل از تغییرات استفاده می‌شود. این دستور جایگزینی مدرن و دقیق برای بخش‌هایی از دستور `git checkout` است.

### 2. **محدوده عمل**

#### `git reset`:

- **HEAD و تاریخچه شاخه:** این دستور به طور مستقیم با HEAD و شاخه فعلی کار می‌کند. شما می‌توانید شاخه‌ی جاری را به یک کامیت قبلی بازگردانید و HEAD را جابه‌جا کنید. علاوه بر این، می‌توانید تعیین کنید که آیا تغییرات در مرحله آماده‌سازی و دایرکتوری کاری نیز تحت تأثیر قرار بگیرند یا نه.

  برای مثال:

  ```bash
  git reset --hard <commit>
  ```

  در این حالت، HEAD، مرحله آماده‌سازی، و دایرکتوری کاری به حالت کامیت مشخص‌شده بازگردانده می‌شوند.

#### `git restore`:

- **فایل‌ها و تغییرات محلی:** این دستور بیشتر روی فایل‌های خاص متمرکز است و به شما اجازه می‌دهد که تغییرات یک یا چند فایل را بازگردانید. `git restore` به شما امکان می‌دهد فایل‌هایی که در مرحله آماده‌سازی قرار دارند یا تغییرات محلی دارند را به حالت قبل بازگردانید.

  برای مثال:

  ```bash
  git restore <filename>
  ```

  در این حالت، فایل مشخص‌شده به آخرین وضعیت در HEAD یا یک کامیت مشخص بازگردانده می‌شود.

### 3. **حالت‌های مختلف و تأثیر آن‌ها**

#### `git reset`:

- **سه حالت اصلی:** `git reset` دارای سه حالت اصلی `--soft`، `--mixed` و `--hard` است که هر کدام محدوده عمل خاصی دارند:
  - `--soft`: فقط HEAD را به کامیت مشخص‌شده بازمی‌گرداند و مرحله آماده‌سازی و دایرکتوری کاری را دست‌نخورده باقی می‌گذارد.
  - `--mixed`: HEAD و مرحله آماده‌سازی را بازمی‌گرداند اما دایرکتوری کاری را بدون تغییر باقی می‌گذارد.
  - `--hard`: HEAD، مرحله آماده‌سازی و دایرکتوری کاری را به کامیت مشخص‌شده بازمی‌گرداند و تمام تغییرات محلی را حذف می‌کند.

#### `git restore`:

- **گزینه‌های مخصوص فایل‌ها:** `git restore` با استفاده از گزینه‌هایی مانند `--staged` و `--worktree` عمل می‌کند:
  - `--staged`: تغییرات فایل را از مرحله آماده‌سازی خارج می‌کند (مشابه `git reset` در فایل‌های خاص).
  - `--worktree`: تغییرات فایل‌ها در دایرکتوری کاری را به حالت آخرین کامیت برمی‌گرداند.

### 4. **تغییر HEAD و شاخه‌ها**

#### `git reset`:

- **جابه‌جایی HEAD و شاخه‌ها:** یکی از قابلیت‌های کلیدی `git reset` این است که می‌تواند HEAD و شاخه فعلی را به کامیت قبلی بازگرداند. به عبارت دیگر، این دستور تاریخچه پروژه را تغییر می‌دهد و شاخه‌ی جاری را به یک نسخه قدیمی‌تر برمی‌گرداند.

  مثال:

  ```bash
  git reset --hard HEAD~2
  ```

  این دستور HEAD و شاخه‌ی جاری را دو کامیت به عقب برمی‌گرداند.

#### `git restore`:

- **عدم تغییر HEAD:** `git restore` هیچ‌گونه تغییراتی در HEAD یا تاریخچه شاخه‌ها ایجاد نمی‌کند. این دستور فقط روی بازگرداندن فایل‌ها در دایرکتوری کاری یا مرحله آماده‌سازی متمرکز است. اگر شما به دنبال تغییر شاخه یا HEAD هستید، باید از دستورات دیگر مانند `git checkout` یا `git reset` استفاده کنید.

### 5. **موارد استفاده متداول**

#### `git reset`:

- **اصلاح تاریخچه:** زمانی که شما می‌خواهید تاریخچه کامیت‌های خود را اصلاح کنید، مثلا چند کامیت اخیر را ترکیب کرده یا تغییرات اعمال‌شده را به طور کامل بازگردانید، `git reset` بهترین ابزار است.
- **بازگرداندن شاخه‌ها:** زمانی که شما می‌خواهید HEAD و شاخه فعلی را به یک وضعیت قبلی بازگردانید.

#### `git restore`:

- **بازگرداندن تغییرات فایل‌ها:** اگر بخواهید تغییرات یک فایل خاص را به حالت قبلی بازگردانید یا فایلی را که به اشتباه مرحله‌بندی کرده‌اید (staged) از مرحله آماده‌سازی خارج کنید، `git restore` مناسب است.
- **مدیریت دقیق‌تر فایل‌ها:** زمانی که شما نیاز دارید تغییرات جزئی در فایل‌های خاص را بدون تغییر در تاریخچه پروژه مدیریت کنید.

### 6. **پس‌زمینه فنی (در پشت صحنه)**

#### `git reset`:

- **بازنشانی HEAD:** زمانی که `git reset` اجرا می‌شود، گیت ابتدا HEAD را به کامیت مشخص‌شده بازمی‌گرداند و سپس بر اساس حالت‌های مختلف (soft، mixed، hard) مرحله آماده‌سازی و دایرکتوری کاری را بازنشانی می‌کند.
- **تغییر در فایل‌های مرجع:** `git reset` فایل‌های مرجع (references) گیت مانند `HEAD` و `refs/heads/main` را تغییر می‌دهد تا نشان دهد که HEAD و شاخه فعلی به کدام کامیت جدید اشاره دارند.

#### `git restore`:

- **بازگرداندن فایل‌ها از کامیت‌ها:** زمانی که `git restore` اجرا می‌شود، گیت به کمک اطلاعات ذخیره‌شده در کامیت‌ها و دایرکتوری `.git/objects/` فایل‌ها را به حالت قبلی بازمی‌گرداند. این دستور هیچ تغییری در HEAD یا فایل‌های مرجع گیت ایجاد نمی‌کند.

### نتیجه‌گیری

در حالی که هر دو دستور `git reset` و `git restore` به بازگرداندن تغییرات کمک می‌کنند، تفاوت‌های فنی و مفهومی بین آن‌ها مشخص است:

- `git reset` یک ابزار قدرتمند برای بازگرداندن HEAD، شاخه‌ها، و همچنین تغییرات در مرحله آماده‌سازی و دایرکتوری کاری است. این دستور بیشتر برای مدیریت تاریخچه و شاخه‌ها کاربرد دارد.
- `git restore` ابزاری مدرن و دقیق برای بازگرداندن تغییرات فایل‌ها است که بدون تغییر در HEAD، به شما اجازه می‌دهد تغییرات محلی و مرحله‌بندی شده فایل‌ها را به حالت قبلی برگردانید.

استفاده از هر کدام از این دستورات بسته به نیاز و هدف شما در مدیریت تغییرات فایل‌ها و تاریخچه پروژه متفاوت است. درک صحیح از هر دو دستور به شما کمک می‌کند که کنترل بهتری بر روی پروژه‌های گیت خود داشته باشید.
